---
title: 容器技术核心知识概述
date: 2024-09-15 12:57
tags:
  - Note
  - Docker
---
## 2.1 什么是容器？

> [!note]
> 容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。

### 容器与虚拟机有什么区别？

![](Blog/Docker/assets/Pasted%20image%2020250301180735.png)

> [!note]
> 容器由两部分组成：
> 1. 应用程序
> 2. 依赖

> [!note]
> 传统的虚拟化技术，都需要创建完整的虚拟机，除了依赖以外，就需要安装整个操作系统。而对于容器技术而言，所有容器都共享同一个Host OS，使得体积大大减少，也不需要再去启动整个操作系统，部署和启动都更快，开销也更小。

## 2.2 为什么需要容器

> [!Hint] 简要
> 容器使得软件具备更强的可移植能力。

### 容器解决了什么问题？

  > [!attention] 面临的挑战
> 在今天，开发人员在进行开发的时候往往需要部署多种服务，在一个系统内，就可能需要完成数据库、缓存、消息队列等多种软件的构建与部署，并且部署的环境也可能复杂多变——虚拟服务器、私有云、公有云等等。
> 而对于这些应用，不同的服务有着不同的库与软件包，依赖各不相同，另外部署环境也可能需要动态的迁移。**我们如何保证每种服务在所有的部署环境中都能顺利运行呢？**

> [!note]
> Docker将集装箱思想运用到软件打包上，为代码提供了一个基于容器的标准化运输系统，并提供了以下的特性：
> - 打包任何软件机器依赖
> - 容器无需修改即可运行在几乎所有平台
> - 资源、网络、库都是隔离的
> - 提供标准化操作，适合自动化部署与维护
> - 轻量级，能快速启动与迁移
> - 解耦开发人员与运维人员的工作职责

> [!Tip] 优势
> - 开发：Build Once, Run AnyWhere!
> - 运维：Configure Once、Run Anything

## 2.3 容器如何工作？

### Docker的架构是怎样的？

> [!summary] Docker核心组件
> 典型的**CS架构**
> - Docker客户端：Client
> - Docker服务器：Docker daemon
> - Docker镜像：Image
> - Registry
> - Docker容器：Container

![](Blog/Docker/assets/Pasted%20image%2020250301180748.png)

#### Docker客户端

> [!note]- Docker客户端支持的操作
> ```shell
> Usage:  docker [OPTIONS] COMMAND
> 
>  self-sufficient runtime for containers
> 
> Common Commands:
>   run         Create and run a new container from an image
>   exec        Execute a command in a running container
>   ps          List containers
> build       Build an image from a Dockerfile
>   pull        Download an image from a registry
>   push        Upload an image to a registry
>   images      List images
>   login       Log in to a registry
>   logout      Log out from a registry
>   search      Search Docker Hub for images
>   version     Show the Docker version information
>   info        Display system-wide information
> 
> Management Commands:
>   builder     Manage builds
>   buildx*     Docker Buildx
>   checkpoint  Manage checkpoints
>   compose*    Docker Compose
>   container   Manage containers
>   context     Manage contexts
>   image       Manage images
>   manifest    Manage Docker image manifests and manifest lists
>   network     Manage networks
>   plugin      Manage plugins
>   system      Manage Docker
>   trust       Manage trust on Docker images
>   volume      Manage volumes
> 
> Swarm Commands:
>   config      Manage Swarm configs
>   node        Manage Swarm nodes
>   secret      Manage Swarm secrets
>   service     Manage Swarm services
>   stack       Manage Swarm stacks
>   swarm       Manage Swarm
> 
> Commands:
>   attach      Attach local standard input, output, and error streams to a running container
>   commit      Create a new image from a container's changes
>   cp          Copy files/folders between a container and the local filesystem
>   create      Create a new container
>   diff        Inspect changes to files or directories on a container's filesystem
>   events      Get real time events from the server
 >  export      Export a container's filesystem as a tar archive
 >  history     Show the history of an image
 >  import      Import the contents from a tarball to create a filesystem image
>   inspect     Return low-level information on Docker objects
>   kill        Kill one or more running containers
>   load        Load an image from a tar archive or STDIN
>   logs        Fetch the logs of a container
>   pause       Pause all processes within one or more containers
>   port        List port mappings or a specific mapping for the container
>   rename      Rename a container
>   restart     Restart one or more containers
>   rm          Remove one or more containers
>   rmi         Remove one or more images
>   save        Save one or more images to a tar archive (streamed to STDOUT by default)
>   start       Start one or more stopped containers
>   stats       Display a live stream of container(s) resource usage statistics
>   stop        Stop one or more running containers
>   tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
 >  top         Display the running processes of a container
>   unpause     Unpause all processes within one or more containers
>   update      Update configuration of one or more containers
>   wait        Block until one or more containers stop, then print their exit codes
> 
> Global Options:
>       --config string      Location of client config files (default "/home/ubuntu/.docker") -c, --context string     Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and
>                            default context set with "docker context use")
>   -D, --debug              Enable debug mode
>   -H, --host list          Daemon socket to connect to
>   -l, --log-level string   Set the logging level ("debug", "info", "warn", "error", "fatal") (default "info")
 >      --tls                Use TLS; implied by --tlsverify
 >      --tlscacert string   Trust certs signed only by this CA (default "/home/ubuntu/.docker/ca.pem")
>       --tlscert string     Path to TLS certificate file (default "/home/ubuntu/.docker/cert.pem")
>       --tlskey string      Path to TLS key file (default "/home/ubuntu/.docker/key.pem")
>       --tlsverify          Use TLS and verify the remote
 >  -v, --version            Print version information and quit
> 
> Run 'docker COMMAND --help' for more information on a command.
> 
> For more help on how to use Docker, head to https://docs.docker.com/go/guides/
> ```

#### Docker服务器

```shell
systemctl status docker.service
● docker.service - Docker Application Container Engine
     Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)
     Active: active (running) since Wed 2024-09-11 07:30:44 CST; 4 days ago
TriggeredBy: ● docker.socket
       Docs: https://docs.docker.com
   Main PID: 2979585 (dockerd)
      Tasks: 26
     Memory: 84.4M
        CPU: 19.593s
     CGroup: /system.slice/docker.service
```

> [!note]
> Docker daemon是服务器组件，以Linux后台服务（守护进程）的方式运行，运行在Docker host上，负责创建、运行、监控容器，创建与存储镜像。

##### 如何配置允许客户端远程请求

> [!tip]
> 1. 编辑配置文件 `/etc/systemd/system/multi-user.target.wants/docker.service`，在环境变量 `ExecStart` 后添加 `-H tcp://0.0.0.0`
> 2. 重启Docker daemon
> 	```shell
> 	systemctl daemon-reload
> 	systemctl restart docker.service
> 	```
> 3. 客户端连接，info查看服务器信息
> 	```shell
> 	docker -H 192.168.x.x info
> 	```

### Docker镜像

> [!note]
> 我们可以认为，Docker镜像就是一个只读的模板，我们可以通过它来创建Docker容器
> 而创建容器则可以通过以下几种方法：
> 1. 从零创建镜像
> 2. 下载并使用已有镜像
> 3. 基于现有镜像创建新的镜像
> 而对应的镜像文件也被称为 Dockerfile，一般通过 `docker build <dockerfile>` 来使用

### Docker容器

> [!note]
> 其实就是 Docker 镜像的运行示例

### Registry

> [!note]
> Registry是存放Docker镜像的仓库，Registry分私有和公有两种。
> - `docker pull` 从仓库拉取镜像
> - `docker run` 直接拉取镜像（如果本地没有），然后启动容器

